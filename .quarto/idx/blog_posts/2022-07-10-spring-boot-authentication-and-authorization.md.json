{"title":"Spring Boot Authentication and Authorization","markdown":{"yaml":{"title":"Spring Boot Authentication and Authorization","date":"2022-07-10","reading-time":"5 min read","categories":"spring-boot","image":"https://cdn-images-1.medium.com/max/1024/0*B2N27hdw1u8-4Gv0"},"containsRefs":false,"markdown":"\n\n[click here to read this in medium](https://guttikondaparthasai.medium.com/spring-boot-authentication-and-authorization-8182e9c1f735?source=rss-2c47946b91eb------2)\n\n<p>Spring security, JWT, Authorisations</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*B2N27hdw1u8-4Gv0\" /><figcaption>Photo by <a href=\"https://unsplash.com/@bergerteam?utm_source=medium&amp;utm_medium=referral\">Florian Berger</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>ü•∑ What we¬†do</h4><p>In this article, We will be creating a Spring boot application to demonstrate Authentication and Authorization to users. For this Demo, we will be using MongoDB database. Also For this Authentication we will be using JWT Standard, and we will be using HS512 algorithm to encode the information.</p><h4>üéØDependencies used¬†:</h4><p>please view at <a href=\"https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle\">link</a>¬†. (<a href=\"https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle\">https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle</a>)</p><h4>üßû‚Äç‚ôÇÔ∏èSteps To be¬†followed</h4><ul><li>Create domain and repository for Both users and Authorities.</li><li>Prepare JWT and Security Utilities.</li><li>Configure spring security and JWT¬†Filters.</li><li>mongock ChangeLog to add initial users to DataBase.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VB5_uRnrQ_sYmhK4\" /><figcaption>Photo by <a href=\"https://unsplash.com/@ispywithmylittleeye?utm_source=medium&amp;utm_medium=referral\">Zeynep S√ºmer</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Document Structures of Both User and Authorities</h4><p>Authority.java</p><pre><em>/**<br /> * An authority (a security role) used by Spring Security.<br /> */<br /></em>@Document(collection = &quot;authority&quot;)<br />public class Authority implements Serializable {<br /><br />    private static final long <em>serialVersionUID </em>= 1L;<br /><br />    @NotNull<br />    @Size(max = 50)<br />    @Id<br />    private String name;<br /><br />    public String getName() {<br />        return name;<br />    }<br /><br />    public void setName(String name) {<br />        this.name = name;<br />    }<br /><br />    @Override<br />    public boolean equals(Object o) {<br />        if (this == o) {<br />            return true;<br />        }<br />        if (!(o instanceof Authority)) {<br />            return false;<br />        }<br />        return Objects.<em>equals</em>(name, ((Authority) o).name);<br />    }<br /><br />    @Override<br />    public int hashCode() {<br />        return Objects.<em>hashCode</em>(name);<br />    }<br /><br />    <em>// prettier-ignore<br />    </em>@Override<br />    public String toString() {<br />        return &quot;Authority{&quot; +<br />            &quot;name='&quot; + name + '\\'' +<br />            &quot;}&quot;;<br />    }<br />}</pre><p>User.java</p><pre><em>/**<br /> * A user.<br /> */<br /></em>@org.springframework.data.mongodb.core.mapping.Document(collection = &quot;user&quot;)<br />public class User extends AbstractAuditingEntity implements Serializable {<br /><br />    private static final long <em>serialVersionUID </em>= 1L;<br /><br />    @Id<br />    private String id;<br /><br />    @NotNull<br />    @Pattern(regexp = Constants.<em>LOGIN_REGEX</em>)<br />    @Size(min = 1, max = 50)<br />    @Indexed<br />    private String login;<br /><br />    @JsonIgnore<br />    @NotNull<br />    @Size(min = 60, max = 60)<br />    private String password;<br /><br />    @Size(max = 50)<br />    @Field(&quot;first_name&quot;)<br />    private String firstName;<br /><br />    @Size(max = 50)<br />    @Field(&quot;last_name&quot;)<br />    private String lastName;<br /><br />    @Email<br />    @Size(min = 5, max = 254)<br />    @Indexed<br />    private String email;<br /><br />    private boolean activated = false;<br /><br />    @Size(min = 2, max = 10)<br />    @Field(&quot;lang_key&quot;)<br />    private String langKey;<br /><br />    @Size(max = 256)<br />    @Field(&quot;image_url&quot;)<br />    private String imageUrl;<br /><br />    @Size(max = 20)<br />    @Field(&quot;activation_key&quot;)<br />    @JsonIgnore<br />    private String activationKey;<br /><br />    @Size(max = 20)<br />    @Field(&quot;reset_key&quot;)<br />    @JsonIgnore<br />    private String resetKey;<br /><br />    @Field(&quot;reset_date&quot;)<br />    private Instant resetDate = null;<br /><br />    @JsonIgnore<br />    private Set&lt;Authority&gt; authorities = new HashSet&lt;&gt;();<br />}</pre><p>UserRepository.java</p><pre>@Repository<br />public interface UserRepository extends MongoRepository&lt;User, String&gt; {<br />    Optional&lt;User&gt; findOneByActivationKey(String activationKey);<br /><br />    List&lt;User&gt; findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant dateTime);<br /><br />    Optional&lt;User&gt; findOneByResetKey(String resetKey);<br /><br />    Optional&lt;User&gt; findOneByEmailIgnoreCase(String email);<br /><br />    Optional&lt;User&gt; findOneByLogin(String login);<br /><br />    Page&lt;User&gt; findAllByIdNotNullAndActivatedIsTrue(Pageable pageable);<br />}</pre><p>AuthorityRepository.java</p><pre><em>/**<br /> * Spring Data MongoDB repository for the {@link Authority} entity.<br /> */<br /></em>public interface AuthorityRepository extends MongoRepository&lt;Authority, String&gt; {}</pre><p>AuthoritiesConstants.java</p><pre>public final class AuthoritiesConstants {<br /><br />    public static final String <em>ADMIN </em>= &quot;ROLE_ADMIN&quot;;<br /><br />    public static final String <em>USER </em>= &quot;ROLE_USER&quot;;<br /><br />    public static final String <em>ANONYMOUS </em>= &quot;ROLE_ANONYMOUS&quot;;<br /><br />    private AuthoritiesConstants() {}<br />}</pre><h3>JWT Things</h3><h3>üëâ JWT working¬†Flow:-</h3><ul><li><strong>JSON Web Token(JWT)</strong> is an open standard used to share security information between two parties like client and server. It follows one particular cryptographic algorithm to encrypt and decrypt the JSON Objects. Algorithms like Hash 512,Hash 256, RS256¬†etc.</li><li>When a user registers in an application, user details are sent to the server. While saving the user details. We will ensure to <strong>encrypt the password</strong> while saving into the database.(<strong>BCryptPasswordEncoder</strong>)</li><li>When a user logs in to the application, details like username and password will be sent to the server. There we will be <strong>verifying the password with encrypted password</strong>. If matches, we will be creating an <strong>JWT token</strong> and sent it as a response.</li><li>After getting the <strong>JWT token, we need to append the token in the header</strong> of HTTP request (For all secured endpoints, we need to follow the¬†same).</li><li>The JWT token contains three parts <strong>(HEADER, PAYLOAD)are Base64-URL encoded JSON and Cryptographic Signature.<br />Note</strong>:- We need a secret key to encrypt and decrypt¬†data.</li><li>For Authorization, we will be adding the roles of the user to the token¬†itself.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*uPHcBHX7FSEoe-Jp\" /><figcaption>Photo by <a href=\"https://unsplash.com/@calina?utm_source=medium&amp;utm_medium=referral\">Georg Bommeli</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>TokenProvider.java<br />Here we will be writing the methods to createTokens, getAuthentications from token and validate token.<br />Replace ‚ÄúKEY‚Äù with secretKey.</p><pre>@Component<br />public class TokenProvider {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(TokenProvider.class);<br /><br />    private static final String <em>AUTHORITIES_KEY </em>= &quot;auth&quot;;<br /><br />    private final Key key;<br /><br />    private final JwtParser jwtParser;<br /><br />    private final long tokenValidityInMilliseconds;<br /><br />    private final long tokenValidityInMillisecondsForRememberMe;<br /><br />    public TokenProvider() {<br />        byte[] keyBytes;<br />        String secret = &quot;KEY&quot;;<br />        if (!ObjectUtils.<em>isEmpty</em>(secret)) {<br />            log.debug(&quot;Using a Base64-encoded JWT secret key&quot;);<br />            keyBytes = Decoders.<em>BASE64</em>.decode(secret);<br />        } else {<br />            log.warn(<br />                &quot;Warning: the JWT key used is not Base64-encoded. &quot; +<br />                &quot;We recommend using the `jhipster.security.authentication.jwt.base64-secret` key for optimum security.&quot;<br />            );<br />            secret = &quot;YWQzMmJiZjgwMDliY2M4NWE0ZjVkOWUxZmRjYTcwMDc2OTZkN2Y5MzQ3ODQ4N2M2YmExNTVmNDFjMDdhZGUzZDRmZDE2OGFkMTc1NmE4MWVmYTIxZDI3YWIzZTNhNzQ1YjNhMzE1ZGVmMWRhNWQxZGFhN2I3NjQzMWRkNjczODY=&quot;;<br />            keyBytes = secret.getBytes(StandardCharsets.<em>UTF_8</em>);<br />        }<br />        key = Keys.<em>hmacShaKeyFor</em>(keyBytes);<br />        jwtParser = Jwts.<em>parserBuilder</em>().setSigningKey(key).build();<br />        this.tokenValidityInMilliseconds = 1000 * 700;<br />        this.tokenValidityInMillisecondsForRememberMe = 1000 * 700;<br />    }<br /><br />    public String createToken(Authentication authentication, boolean rememberMe) {<br />        String authorities = authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.<em>joining</em>(&quot;,&quot;));<br /><br />        long now = (new Date()).getTime();<br />        Date validity;<br />        if (rememberMe) {<br />            validity = new Date(now + this.tokenValidityInMillisecondsForRememberMe);<br />        } else {<br />            validity = new Date(now + this.tokenValidityInMilliseconds);<br />        }<br /><br />        return Jwts<br />            .<em>builder</em>()<br />            .setSubject(authentication.getName())<br />            .claim(<em>AUTHORITIES_KEY</em>, authorities)<br />            .signWith(key, SignatureAlgorithm.<em>HS512</em>)<br />            .setExpiration(validity)<br />            .compact();<br />    }<br /><br />    public Authentication getAuthentication(String token) {<br />        Claims claims = jwtParser.parseClaimsJws(token).getBody();<br /><br />        Collection&lt;? extends GrantedAuthority&gt; authorities = Arrays<br />            .<em>stream</em>(claims.get(<em>AUTHORITIES_KEY</em>).toString().split(&quot;,&quot;))<br />            .filter(auth -&gt; !auth.trim().isEmpty())<br />            .map(SimpleGrantedAuthority::new)<br />            .collect(Collectors.<em>toList</em>());<br /><br />        User principal = new User(claims.getSubject(), &quot;&quot;, authorities);<br /><br />        return new UsernamePasswordAuthenticationToken(principal, token, authorities);<br />    }<br /><br />    public boolean validateToken(String authToken) {<br />        try {<br />            jwtParser.parseClaimsJws(authToken);<br />            return true;<br />        } catch (JwtException | IllegalArgumentException e) {<br />            log.info(&quot;Invalid JWT token.&quot;);<br />            log.trace(&quot;Invalid JWT token trace.&quot;, e);<br />        }<br />        return false;<br />    }<br />}</pre><p>JWTConfigurer.java<br />Now We need to add JWTFilter with tokenProvider to the HttpSecurity, That can be overwritten by extending SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;.</p><pre>public class JWTConfigurer extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {<br /><br />    private final TokenProvider tokenProvider;<br /><br />    public JWTConfigurer(TokenProvider tokenProvider) {<br />        this.tokenProvider = tokenProvider;<br />    }<br /><br />    @Override<br />    public void configure(HttpSecurity http) {<br />        JWTFilter customFilter = new JWTFilter(tokenProvider);<br />        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);<br />    }<br />}</pre><p>JWTFilter.java<br />This class will be extending the GenericFilterBean class and we can add Filter by overriding doFilter method. So here we will be validating all the request with bearer token. if the request do not have it can access only public¬†API‚Äôs.</p><pre>public class JWTFilter extends GenericFilterBean {<br /><br />    public static final String <em>AUTHORIZATION_HEADER </em>= &quot;Authorization&quot;;<br /><br />    private final TokenProvider tokenProvider;<br /><br />    public JWTFilter(TokenProvider tokenProvider) {<br />        this.tokenProvider = tokenProvider;<br />    }<br /><br />    @Override<br />    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)<br />        throws IOException, ServletException {<br />        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;<br />        String jwt = resolveToken(httpServletRequest);<br />        if (StringUtils.<em>hasText</em>(jwt) &amp;&amp; this.tokenProvider.validateToken(jwt)) {<br />            Authentication authentication = this.tokenProvider.getAuthentication(jwt);<br />            SecurityContextHolder.<em>getContext</em>().setAuthentication(authentication);<br />        }<br />        filterChain.doFilter(servletRequest, servletResponse);<br />    }<br /><br />    private String resolveToken(HttpServletRequest request) {<br />        String bearerToken = request.getHeader(<em>AUTHORIZATION_HEADER</em>);<br />        if (StringUtils.<em>hasText</em>(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {<br />            return bearerToken.substring(7);<br />        }<br />        return null;<br />    }<br />}</pre><p>Service which provides user details from DataBase need to be declared as component to avoid dependency cycle in our¬†project.</p><pre><em>/**<br /> * Authenticate a user from the database.<br /> */<br /></em>@Component(&quot;userDetailsService&quot;)<br />public class DomainUserDetailsService implements UserDetailsService {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(DomainUserDetailsService.class);<br /><br />    private final UserRepository userRepository;<br /><br />    public DomainUserDetailsService(UserRepository userRepository) {<br />        this.userRepository = userRepository;<br />    }<br /><br />    @Override<br />    public UserDetails loadUserByUsername(final String login) {<br />        log.debug(&quot;Authenticating {}&quot;, login);<br /><br />        if (new EmailValidator().isValid(login, null)) {<br />            return userRepository<br />                .findOneByEmailIgnoreCase(login)<br />                .map(user -&gt; createSpringSecurityUser(login, user))<br />                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User with email &quot; + login + &quot; was not found in the database&quot;));<br />        }<br /><br />        String lowercaseLogin = login.toLowerCase(Locale.<em>ENGLISH</em>);<br />        return userRepository<br />            .findOneByLogin(lowercaseLogin)<br />            .map(user -&gt; createSpringSecurityUser(lowercaseLogin, user))<br />            .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User &quot; + lowercaseLogin + &quot; was not found in the database&quot;));<br />    }<br /><br />    private org.springframework.security.core.userdetails.User createSpringSecurityUser(String lowercaseLogin, User user) {<br />        if (!user.isActivated()) {<br />            throw new UserNotActivatedException(&quot;User &quot; + lowercaseLogin + &quot; was not activated&quot;);<br />        }<br />        List&lt;GrantedAuthority&gt; grantedAuthorities = user<br />            .getAuthorities()<br />            .stream()<br />            .map(authority -&gt; new SimpleGrantedAuthority(authority.getName()))<br />            .collect(Collectors.<em>toList</em>());<br />        return new org.springframework.security.core.userdetails.User(user.getLogin(), user.getPassword(), grantedAuthorities);<br />    }<br />}</pre><p>SecurityUtils.java<br />Here we will be writing methods related to current user login like getCurrentUserName etc.</p><pre><em>/**<br /> * Utility class for Spring Security.<br /> */<br /></em>public final class SecurityUtils {<br /><br />    private SecurityUtils() {}<br /><br />    <em>/**<br />     * Get the login of the current user.<br />     *<br />     * @return the login of the current user.<br />     */<br />    </em>public static Optional&lt;String&gt; getCurrentUserLogin() {<br />        SecurityContext securityContext = SecurityContextHolder.<em>getContext</em>();<br />        return Optional.<em>ofNullable</em>(<em>extractPrincipal</em>(securityContext.getAuthentication()));<br />    }<br /><br />    private static String extractPrincipal(Authentication authentication) {<br />        if (authentication == null) {<br />            return null;<br />        } else if (authentication.getPrincipal() instanceof UserDetails) {<br />            UserDetails springSecurityUser = (UserDetails) authentication.getPrincipal();<br />            return springSecurityUser.getUsername();<br />        } else if (authentication.getPrincipal() instanceof String) {<br />            return (String) authentication.getPrincipal();<br />        }<br />        return null;<br />    }<br /><br />    <em>/**<br />     * Get the JWT of the current user.<br />     *<br />     * @return the JWT of the current user.<br />     */<br />    </em>public static Optional&lt;String&gt; getCurrentUserJWT() {<br />        SecurityContext securityContext = SecurityContextHolder.<em>getContext</em>();<br />        return Optional<br />            .<em>ofNullable</em>(securityContext.getAuthentication())<br />            .filter(authentication -&gt; authentication.getCredentials() instanceof String)<br />            .map(authentication -&gt; (String) authentication.getCredentials());<br />    }<br /><br />    <em>/**<br />     * Check if a user is authenticated.<br />     *<br />     * @return true if the user is authenticated, false otherwise.<br />     */<br />    </em>public static boolean isAuthenticated() {<br />        Authentication authentication = SecurityContextHolder.<em>getContext</em>().getAuthentication();<br />        return authentication != null &amp;&amp; <em>getAuthorities</em>(authentication).noneMatch(AuthoritiesConstants.<em>ANONYMOUS</em>::equals);<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has any of the authorities.<br />     *<br />     * @param authorities the authorities to check.<br />     * @return true if the current user has any of the authorities, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserAnyOfAuthorities(String... authorities) {<br />        Authentication authentication = SecurityContextHolder.<em>getContext</em>().getAuthentication();<br />        return (<br />            authentication != null &amp;&amp; <em>getAuthorities</em>(authentication).anyMatch(authority -&gt; Arrays.<em>asList</em>(authorities).contains(authority))<br />        );<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has none of the authorities.<br />     *<br />     * @param authorities the authorities to check.<br />     * @return true if the current user has none of the authorities, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserNoneOfAuthorities(String... authorities) {<br />        return !<em>hasCurrentUserAnyOfAuthorities</em>(authorities);<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has a specific authority.<br />     *<br />     * @param authority the authority to check.<br />     * @return true if the current user has the authority, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserThisAuthority(String authority) {<br />        return <em>hasCurrentUserAnyOfAuthorities</em>(authority);<br />    }<br /><br />    private static Stream&lt;String&gt; getAuthorities(Authentication authentication) {<br />        return authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority);<br />    }<br />}</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*sA1fdRXDyh0m3piZ\" /><figcaption>Photo by <a href=\"https://unsplash.com/@fantasyflip?utm_source=medium&amp;utm_medium=referral\">Philipp Katzenberger</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Security Configurations</h4><p>SecurityConfiguration.java<br />Here we will be saying what kind of api‚Äôs need to be permitted as public¬†api‚Äôs.</p><pre>@EnableWebSecurity<br />@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)<br />@Import(SecurityProblemSupport.class)<br />public class SecurityConfiguration extends WebSecurityConfigurerAdapter {<br /><br />    private final TokenProvider tokenProvider;<br /><br />    private final CorsFilter corsFilter;<br />    private final SecurityProblemSupport problemSupport;<br /><br />    public SecurityConfiguration(<br />        TokenProvider tokenProvider,<br />        CorsFilter corsFilter,<br />        SecurityProblemSupport problemSupport<br />    ) {<br />        this.tokenProvider = tokenProvider;<br />        this.corsFilter = corsFilter;<br />        this.problemSupport = problemSupport;<br />    }<br /><br />    @Bean<br />    public PasswordEncoder passwordEncoder() {<br />        return new BCryptPasswordEncoder();<br />    }<br /><br />    @Override<br />    public void configure(WebSecurity web) {<br />        web.ignoring().antMatchers(HttpMethod.<em>OPTIONS</em>, &quot;/**&quot;).antMatchers(&quot;/swagger-ui/**&quot;).antMatchers(&quot;/test/**&quot;);<br />    }<br /><br />    @Override<br />    public void configure(HttpSecurity http) throws Exception {<br />        <em>// @formatter:off<br />        </em>http<br />            .csrf()<br />            .disable()<br />            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)<br />            .exceptionHandling()<br />                .authenticationEntryPoint(problemSupport)<br />                .accessDeniedHandler(problemSupport)<br />        .and()<br />            .headers()<br />            .contentSecurityPolicy(&quot;default-src 'self'; frame-src 'self' data:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://storage.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:&quot;)<br />        .and()<br />            .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.<em>STRICT_ORIGIN_WHEN_CROSS_ORIGIN</em>)<br />        .and()<br />            .permissionsPolicy().policy(&quot;camera=(), fullscreen=(self), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), sync-xhr=()&quot;)<br />        .and()<br />            .frameOptions()<br />            .deny()<br />        .and()<br />            .sessionManagement()<br />            .sessionCreationPolicy(SessionCreationPolicy.<em>STATELESS</em>)<br />        .and()<br />            .authorizeRequests()<br />            .antMatchers(&quot;/api/authenticate&quot;).permitAll()<br />            .antMatchers(&quot;/api/register&quot;).permitAll()<br />            .antMatchers(&quot;/api/activate&quot;).permitAll()<br />            .antMatchers(&quot;/api/account/reset-password/init&quot;).permitAll()<br />            .antMatchers(&quot;/api/account/reset-password/finish&quot;).permitAll()<br />            .antMatchers(&quot;/api/admin/**&quot;).hasAuthority(AuthoritiesConstants.<em>ADMIN</em>)<br />            .antMatchers(&quot;/api/**&quot;).authenticated()<br />            .antMatchers(&quot;/management/health&quot;).permitAll()<br />            .antMatchers(&quot;/management/health/**&quot;).permitAll()<br />            .antMatchers(&quot;/management/info&quot;).permitAll()<br />            .antMatchers(&quot;/management/prometheus&quot;).permitAll()<br />            .antMatchers(&quot;/management/**&quot;).hasAuthority(AuthoritiesConstants.<em>ADMIN</em>)<br />        .and()<br />            .httpBasic()<br />        .and()<br />            .apply(securityConfigurerAdapter());<br />        <em>// @formatter:on<br />    </em>}<br /><br />    private JWTConfigurer securityConfigurerAdapter() {<br />        return new JWTConfigurer(tokenProvider);<br />    }<br />}</pre><p>WebConfigure.java<br />Allowed domains needs be to added here to avoid COR‚Äôs related¬†issues</p><pre><em>/**<br /> * Configuration of web application with Servlet 3.0 APIs.<br /> */<br /></em>@Configuration<br />public class WebConfigurer implements ServletContextInitializer {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(WebConfigurer.class);<br /><br />    private final Environment env;<br /><br />    public WebConfigurer(Environment env) {<br />        this.env = env;<br />    }<br /><br />    @Override<br />    public void onStartup(ServletContext servletContext) throws ServletException {<br />        if (env.getActiveProfiles().length != 0) {<br />            log.info(&quot;Web application configuration, using profiles: {}&quot;, (Object[]) env.getActiveProfiles());<br />        }<br /><br />        log.info(&quot;Web application fully configured&quot;);<br />    }<br /><br />    @Bean<br />    public CorsFilter corsFilter() {<br />        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();<br />        CorsConfiguration config = new CorsConfiguration();<br />        List&lt;String&gt; list = new ArrayList&lt;&gt;();<br />        list.add(&quot;*&quot;);<br />        config.setAllowedOriginPatterns(list);<br />        if (!CollectionUtils.<em>isEmpty</em>(config.getAllowedOrigins()) || !CollectionUtils.<em>isEmpty</em>(config.getAllowedOriginPatterns())) {<br />            log.debug(&quot;Registering CORS filter&quot;);<br />            source.registerCorsConfiguration(&quot;/api/**&quot;, config);<br />            source.registerCorsConfiguration(&quot;/management/**&quot;, config);<br />            source.registerCorsConfiguration(&quot;/v2/api-docs&quot;, config);<br />            source.registerCorsConfiguration(&quot;/v3/api-docs&quot;, config);<br />            source.registerCorsConfiguration(&quot;/swagger-resources&quot;, config);<br />            source.registerCorsConfiguration(&quot;/swagger-ui/**&quot;, config);<br />        }<br />        return new CorsFilter(source);<br />    }<br />}</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*dvInUHmgY9aXjguP\" /><figcaption>Photo by <a href=\"https://unsplash.com/@benjaminlehman?utm_source=medium&amp;utm_medium=referral\">benjamin lehman</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Mongock ChangeLog</h4><p>We will be using mongock to add default user details to database like¬†admin.</p><p>In application.properties we need to give the path of the class which contains ChangeLog annotation.</p><pre>spring.data.mongodb.uri=mongodb://localhost:27017/AuthDemo<br />mongock.change-logs-scan-package=<br />com.pardhu.authdemo.config.InitialSetupMigration</pre><p>InitialSetupMigration.java</p><pre><em>/**<br /> * Creates the initial database setup.<br /> */<br /></em>@ChangeLog(order = &quot;001&quot;)<br />public class InitialSetupMigration {<br /><br />    @ChangeSet(order = &quot;01&quot;, author = &quot;initiator&quot;, id = &quot;01-addAuthorities&quot;)<br />    public void addAuthorities(MongockTemplate mongoTemplate) {<br />        Authority adminAuthority = new Authority();<br />        adminAuthority.setName(AuthoritiesConstants.<em>ADMIN</em>);<br />        Authority userAuthority = new Authority();<br />        userAuthority.setName(AuthoritiesConstants.<em>USER</em>);<br />        mongoTemplate.save(adminAuthority);<br />        mongoTemplate.save(userAuthority);<br />    }<br /><br />    @ChangeSet(order = &quot;02&quot;, author = &quot;initiator&quot;, id = &quot;02-addUsers&quot;)<br />    public void addUsers(MongockTemplate mongoTemplate) {<br />        Authority adminAuthority = new Authority();<br />        adminAuthority.setName(AuthoritiesConstants.<em>ADMIN</em>);<br />        Authority userAuthority = new Authority();<br />        userAuthority.setName(AuthoritiesConstants.<em>USER</em>);<br /><br />        User adminUser = new User();<br />        adminUser.setId(&quot;user-1&quot;);<br />        adminUser.setLogin(&quot;admin&quot;);<br />        adminUser.setPassword(&quot;$2a$10$gSAhZrxMllrbgj/kkK9UceBPpChGWJA7SYIb1Mqo.n5aNLq1/oRrC&quot;);<br />        adminUser.setFirstName(&quot;admin&quot;);<br />        adminUser.setLastName(&quot;Administrator&quot;);<br />        adminUser.setEmail(&quot;admin@localhost&quot;);<br />        adminUser.setActivated(true);<br />        adminUser.setLangKey(&quot;en&quot;);<br />        adminUser.setCreatedBy(Constants.<em>SYSTEM</em>);<br />        adminUser.setCreatedDate(Instant.<em>now</em>());<br />        adminUser.getAuthorities().add(adminAuthority);<br />        adminUser.getAuthorities().add(userAuthority);<br />        mongoTemplate.save(adminUser);<br /><br />        User userUser = new User();<br />        userUser.setId(&quot;user-2&quot;);<br />        userUser.setLogin(&quot;user&quot;);<br />        userUser.setPassword(&quot;$2a$10$VEjxo0jq2YG9Rbk2HmX9S.k1uZBGYUHdUcid3g/vfiEl7lwWgOH/K&quot;);<br />        userUser.setFirstName(&quot;&quot;);<br />        userUser.setLastName(&quot;User&quot;);<br />        userUser.setEmail(&quot;user@localhost&quot;);<br />        userUser.setActivated(true);<br />        userUser.setLangKey(&quot;en&quot;);<br />        userUser.setCreatedBy(Constants.<em>SYSTEM</em>);<br />        userUser.setCreatedDate(Instant.<em>now</em>());<br />        userUser.getAuthorities().add(userAuthority);<br />        mongoTemplate.save(userUser);<br />    }<br />}</pre><p>Now we have two Authorities. Admin and User.<br />While writing an api in controller itself we can annotate like this api can be accessed by admin only using annotations ‚Üí<br />@PreAuthorize(‚ÄúhasAuthority(\\‚Äù‚Äù + AuthoritiesConstants.<em>ADMIN </em>+ ‚Äú\\‚Äù)‚Äù)<br />@PostAuthorize(‚ÄúhasAuthority(\\‚Äù‚Äù + AuthoritiesConstants.<em>ADMIN </em>+¬†‚Äú\\‚Äù)‚Äù)</p><h4>Complete working git repo is available at <a href=\"https://github.com/propardhu/AuthDemoSpringBoot\"><strong>GitHub</strong></a><strong>¬†. Also we wrote few login and register¬†API‚Äôs.</strong></h4><p>Thank you‚Ä¶.</p><p><a href=\"https://guttikondaparthasai.medium.com/\">Pardhu Guttikonda - Medium</a></p><img alt=\"\" height=\"1\" src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8182e9c1f735\" width=\"1\" />\n","srcMarkdownNoYaml":"\n\n[click here to read this in medium](https://guttikondaparthasai.medium.com/spring-boot-authentication-and-authorization-8182e9c1f735?source=rss-2c47946b91eb------2)\n\n<p>Spring security, JWT, Authorisations</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*B2N27hdw1u8-4Gv0\" /><figcaption>Photo by <a href=\"https://unsplash.com/@bergerteam?utm_source=medium&amp;utm_medium=referral\">Florian Berger</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>ü•∑ What we¬†do</h4><p>In this article, We will be creating a Spring boot application to demonstrate Authentication and Authorization to users. For this Demo, we will be using MongoDB database. Also For this Authentication we will be using JWT Standard, and we will be using HS512 algorithm to encode the information.</p><h4>üéØDependencies used¬†:</h4><p>please view at <a href=\"https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle\">link</a>¬†. (<a href=\"https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle\">https://github.com/propardhu/AuthDemoSpringBoot/blob/main/build.gradle</a>)</p><h4>üßû‚Äç‚ôÇÔ∏èSteps To be¬†followed</h4><ul><li>Create domain and repository for Both users and Authorities.</li><li>Prepare JWT and Security Utilities.</li><li>Configure spring security and JWT¬†Filters.</li><li>mongock ChangeLog to add initial users to DataBase.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VB5_uRnrQ_sYmhK4\" /><figcaption>Photo by <a href=\"https://unsplash.com/@ispywithmylittleeye?utm_source=medium&amp;utm_medium=referral\">Zeynep S√ºmer</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Document Structures of Both User and Authorities</h4><p>Authority.java</p><pre><em>/**<br /> * An authority (a security role) used by Spring Security.<br /> */<br /></em>@Document(collection = &quot;authority&quot;)<br />public class Authority implements Serializable {<br /><br />    private static final long <em>serialVersionUID </em>= 1L;<br /><br />    @NotNull<br />    @Size(max = 50)<br />    @Id<br />    private String name;<br /><br />    public String getName() {<br />        return name;<br />    }<br /><br />    public void setName(String name) {<br />        this.name = name;<br />    }<br /><br />    @Override<br />    public boolean equals(Object o) {<br />        if (this == o) {<br />            return true;<br />        }<br />        if (!(o instanceof Authority)) {<br />            return false;<br />        }<br />        return Objects.<em>equals</em>(name, ((Authority) o).name);<br />    }<br /><br />    @Override<br />    public int hashCode() {<br />        return Objects.<em>hashCode</em>(name);<br />    }<br /><br />    <em>// prettier-ignore<br />    </em>@Override<br />    public String toString() {<br />        return &quot;Authority{&quot; +<br />            &quot;name='&quot; + name + '\\'' +<br />            &quot;}&quot;;<br />    }<br />}</pre><p>User.java</p><pre><em>/**<br /> * A user.<br /> */<br /></em>@org.springframework.data.mongodb.core.mapping.Document(collection = &quot;user&quot;)<br />public class User extends AbstractAuditingEntity implements Serializable {<br /><br />    private static final long <em>serialVersionUID </em>= 1L;<br /><br />    @Id<br />    private String id;<br /><br />    @NotNull<br />    @Pattern(regexp = Constants.<em>LOGIN_REGEX</em>)<br />    @Size(min = 1, max = 50)<br />    @Indexed<br />    private String login;<br /><br />    @JsonIgnore<br />    @NotNull<br />    @Size(min = 60, max = 60)<br />    private String password;<br /><br />    @Size(max = 50)<br />    @Field(&quot;first_name&quot;)<br />    private String firstName;<br /><br />    @Size(max = 50)<br />    @Field(&quot;last_name&quot;)<br />    private String lastName;<br /><br />    @Email<br />    @Size(min = 5, max = 254)<br />    @Indexed<br />    private String email;<br /><br />    private boolean activated = false;<br /><br />    @Size(min = 2, max = 10)<br />    @Field(&quot;lang_key&quot;)<br />    private String langKey;<br /><br />    @Size(max = 256)<br />    @Field(&quot;image_url&quot;)<br />    private String imageUrl;<br /><br />    @Size(max = 20)<br />    @Field(&quot;activation_key&quot;)<br />    @JsonIgnore<br />    private String activationKey;<br /><br />    @Size(max = 20)<br />    @Field(&quot;reset_key&quot;)<br />    @JsonIgnore<br />    private String resetKey;<br /><br />    @Field(&quot;reset_date&quot;)<br />    private Instant resetDate = null;<br /><br />    @JsonIgnore<br />    private Set&lt;Authority&gt; authorities = new HashSet&lt;&gt;();<br />}</pre><p>UserRepository.java</p><pre>@Repository<br />public interface UserRepository extends MongoRepository&lt;User, String&gt; {<br />    Optional&lt;User&gt; findOneByActivationKey(String activationKey);<br /><br />    List&lt;User&gt; findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant dateTime);<br /><br />    Optional&lt;User&gt; findOneByResetKey(String resetKey);<br /><br />    Optional&lt;User&gt; findOneByEmailIgnoreCase(String email);<br /><br />    Optional&lt;User&gt; findOneByLogin(String login);<br /><br />    Page&lt;User&gt; findAllByIdNotNullAndActivatedIsTrue(Pageable pageable);<br />}</pre><p>AuthorityRepository.java</p><pre><em>/**<br /> * Spring Data MongoDB repository for the {@link Authority} entity.<br /> */<br /></em>public interface AuthorityRepository extends MongoRepository&lt;Authority, String&gt; {}</pre><p>AuthoritiesConstants.java</p><pre>public final class AuthoritiesConstants {<br /><br />    public static final String <em>ADMIN </em>= &quot;ROLE_ADMIN&quot;;<br /><br />    public static final String <em>USER </em>= &quot;ROLE_USER&quot;;<br /><br />    public static final String <em>ANONYMOUS </em>= &quot;ROLE_ANONYMOUS&quot;;<br /><br />    private AuthoritiesConstants() {}<br />}</pre><h3>JWT Things</h3><h3>üëâ JWT working¬†Flow:-</h3><ul><li><strong>JSON Web Token(JWT)</strong> is an open standard used to share security information between two parties like client and server. It follows one particular cryptographic algorithm to encrypt and decrypt the JSON Objects. Algorithms like Hash 512,Hash 256, RS256¬†etc.</li><li>When a user registers in an application, user details are sent to the server. While saving the user details. We will ensure to <strong>encrypt the password</strong> while saving into the database.(<strong>BCryptPasswordEncoder</strong>)</li><li>When a user logs in to the application, details like username and password will be sent to the server. There we will be <strong>verifying the password with encrypted password</strong>. If matches, we will be creating an <strong>JWT token</strong> and sent it as a response.</li><li>After getting the <strong>JWT token, we need to append the token in the header</strong> of HTTP request (For all secured endpoints, we need to follow the¬†same).</li><li>The JWT token contains three parts <strong>(HEADER, PAYLOAD)are Base64-URL encoded JSON and Cryptographic Signature.<br />Note</strong>:- We need a secret key to encrypt and decrypt¬†data.</li><li>For Authorization, we will be adding the roles of the user to the token¬†itself.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*uPHcBHX7FSEoe-Jp\" /><figcaption>Photo by <a href=\"https://unsplash.com/@calina?utm_source=medium&amp;utm_medium=referral\">Georg Bommeli</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>TokenProvider.java<br />Here we will be writing the methods to createTokens, getAuthentications from token and validate token.<br />Replace ‚ÄúKEY‚Äù with secretKey.</p><pre>@Component<br />public class TokenProvider {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(TokenProvider.class);<br /><br />    private static final String <em>AUTHORITIES_KEY </em>= &quot;auth&quot;;<br /><br />    private final Key key;<br /><br />    private final JwtParser jwtParser;<br /><br />    private final long tokenValidityInMilliseconds;<br /><br />    private final long tokenValidityInMillisecondsForRememberMe;<br /><br />    public TokenProvider() {<br />        byte[] keyBytes;<br />        String secret = &quot;KEY&quot;;<br />        if (!ObjectUtils.<em>isEmpty</em>(secret)) {<br />            log.debug(&quot;Using a Base64-encoded JWT secret key&quot;);<br />            keyBytes = Decoders.<em>BASE64</em>.decode(secret);<br />        } else {<br />            log.warn(<br />                &quot;Warning: the JWT key used is not Base64-encoded. &quot; +<br />                &quot;We recommend using the `jhipster.security.authentication.jwt.base64-secret` key for optimum security.&quot;<br />            );<br />            secret = &quot;YWQzMmJiZjgwMDliY2M4NWE0ZjVkOWUxZmRjYTcwMDc2OTZkN2Y5MzQ3ODQ4N2M2YmExNTVmNDFjMDdhZGUzZDRmZDE2OGFkMTc1NmE4MWVmYTIxZDI3YWIzZTNhNzQ1YjNhMzE1ZGVmMWRhNWQxZGFhN2I3NjQzMWRkNjczODY=&quot;;<br />            keyBytes = secret.getBytes(StandardCharsets.<em>UTF_8</em>);<br />        }<br />        key = Keys.<em>hmacShaKeyFor</em>(keyBytes);<br />        jwtParser = Jwts.<em>parserBuilder</em>().setSigningKey(key).build();<br />        this.tokenValidityInMilliseconds = 1000 * 700;<br />        this.tokenValidityInMillisecondsForRememberMe = 1000 * 700;<br />    }<br /><br />    public String createToken(Authentication authentication, boolean rememberMe) {<br />        String authorities = authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.<em>joining</em>(&quot;,&quot;));<br /><br />        long now = (new Date()).getTime();<br />        Date validity;<br />        if (rememberMe) {<br />            validity = new Date(now + this.tokenValidityInMillisecondsForRememberMe);<br />        } else {<br />            validity = new Date(now + this.tokenValidityInMilliseconds);<br />        }<br /><br />        return Jwts<br />            .<em>builder</em>()<br />            .setSubject(authentication.getName())<br />            .claim(<em>AUTHORITIES_KEY</em>, authorities)<br />            .signWith(key, SignatureAlgorithm.<em>HS512</em>)<br />            .setExpiration(validity)<br />            .compact();<br />    }<br /><br />    public Authentication getAuthentication(String token) {<br />        Claims claims = jwtParser.parseClaimsJws(token).getBody();<br /><br />        Collection&lt;? extends GrantedAuthority&gt; authorities = Arrays<br />            .<em>stream</em>(claims.get(<em>AUTHORITIES_KEY</em>).toString().split(&quot;,&quot;))<br />            .filter(auth -&gt; !auth.trim().isEmpty())<br />            .map(SimpleGrantedAuthority::new)<br />            .collect(Collectors.<em>toList</em>());<br /><br />        User principal = new User(claims.getSubject(), &quot;&quot;, authorities);<br /><br />        return new UsernamePasswordAuthenticationToken(principal, token, authorities);<br />    }<br /><br />    public boolean validateToken(String authToken) {<br />        try {<br />            jwtParser.parseClaimsJws(authToken);<br />            return true;<br />        } catch (JwtException | IllegalArgumentException e) {<br />            log.info(&quot;Invalid JWT token.&quot;);<br />            log.trace(&quot;Invalid JWT token trace.&quot;, e);<br />        }<br />        return false;<br />    }<br />}</pre><p>JWTConfigurer.java<br />Now We need to add JWTFilter with tokenProvider to the HttpSecurity, That can be overwritten by extending SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;.</p><pre>public class JWTConfigurer extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {<br /><br />    private final TokenProvider tokenProvider;<br /><br />    public JWTConfigurer(TokenProvider tokenProvider) {<br />        this.tokenProvider = tokenProvider;<br />    }<br /><br />    @Override<br />    public void configure(HttpSecurity http) {<br />        JWTFilter customFilter = new JWTFilter(tokenProvider);<br />        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);<br />    }<br />}</pre><p>JWTFilter.java<br />This class will be extending the GenericFilterBean class and we can add Filter by overriding doFilter method. So here we will be validating all the request with bearer token. if the request do not have it can access only public¬†API‚Äôs.</p><pre>public class JWTFilter extends GenericFilterBean {<br /><br />    public static final String <em>AUTHORIZATION_HEADER </em>= &quot;Authorization&quot;;<br /><br />    private final TokenProvider tokenProvider;<br /><br />    public JWTFilter(TokenProvider tokenProvider) {<br />        this.tokenProvider = tokenProvider;<br />    }<br /><br />    @Override<br />    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)<br />        throws IOException, ServletException {<br />        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;<br />        String jwt = resolveToken(httpServletRequest);<br />        if (StringUtils.<em>hasText</em>(jwt) &amp;&amp; this.tokenProvider.validateToken(jwt)) {<br />            Authentication authentication = this.tokenProvider.getAuthentication(jwt);<br />            SecurityContextHolder.<em>getContext</em>().setAuthentication(authentication);<br />        }<br />        filterChain.doFilter(servletRequest, servletResponse);<br />    }<br /><br />    private String resolveToken(HttpServletRequest request) {<br />        String bearerToken = request.getHeader(<em>AUTHORIZATION_HEADER</em>);<br />        if (StringUtils.<em>hasText</em>(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {<br />            return bearerToken.substring(7);<br />        }<br />        return null;<br />    }<br />}</pre><p>Service which provides user details from DataBase need to be declared as component to avoid dependency cycle in our¬†project.</p><pre><em>/**<br /> * Authenticate a user from the database.<br /> */<br /></em>@Component(&quot;userDetailsService&quot;)<br />public class DomainUserDetailsService implements UserDetailsService {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(DomainUserDetailsService.class);<br /><br />    private final UserRepository userRepository;<br /><br />    public DomainUserDetailsService(UserRepository userRepository) {<br />        this.userRepository = userRepository;<br />    }<br /><br />    @Override<br />    public UserDetails loadUserByUsername(final String login) {<br />        log.debug(&quot;Authenticating {}&quot;, login);<br /><br />        if (new EmailValidator().isValid(login, null)) {<br />            return userRepository<br />                .findOneByEmailIgnoreCase(login)<br />                .map(user -&gt; createSpringSecurityUser(login, user))<br />                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User with email &quot; + login + &quot; was not found in the database&quot;));<br />        }<br /><br />        String lowercaseLogin = login.toLowerCase(Locale.<em>ENGLISH</em>);<br />        return userRepository<br />            .findOneByLogin(lowercaseLogin)<br />            .map(user -&gt; createSpringSecurityUser(lowercaseLogin, user))<br />            .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User &quot; + lowercaseLogin + &quot; was not found in the database&quot;));<br />    }<br /><br />    private org.springframework.security.core.userdetails.User createSpringSecurityUser(String lowercaseLogin, User user) {<br />        if (!user.isActivated()) {<br />            throw new UserNotActivatedException(&quot;User &quot; + lowercaseLogin + &quot; was not activated&quot;);<br />        }<br />        List&lt;GrantedAuthority&gt; grantedAuthorities = user<br />            .getAuthorities()<br />            .stream()<br />            .map(authority -&gt; new SimpleGrantedAuthority(authority.getName()))<br />            .collect(Collectors.<em>toList</em>());<br />        return new org.springframework.security.core.userdetails.User(user.getLogin(), user.getPassword(), grantedAuthorities);<br />    }<br />}</pre><p>SecurityUtils.java<br />Here we will be writing methods related to current user login like getCurrentUserName etc.</p><pre><em>/**<br /> * Utility class for Spring Security.<br /> */<br /></em>public final class SecurityUtils {<br /><br />    private SecurityUtils() {}<br /><br />    <em>/**<br />     * Get the login of the current user.<br />     *<br />     * @return the login of the current user.<br />     */<br />    </em>public static Optional&lt;String&gt; getCurrentUserLogin() {<br />        SecurityContext securityContext = SecurityContextHolder.<em>getContext</em>();<br />        return Optional.<em>ofNullable</em>(<em>extractPrincipal</em>(securityContext.getAuthentication()));<br />    }<br /><br />    private static String extractPrincipal(Authentication authentication) {<br />        if (authentication == null) {<br />            return null;<br />        } else if (authentication.getPrincipal() instanceof UserDetails) {<br />            UserDetails springSecurityUser = (UserDetails) authentication.getPrincipal();<br />            return springSecurityUser.getUsername();<br />        } else if (authentication.getPrincipal() instanceof String) {<br />            return (String) authentication.getPrincipal();<br />        }<br />        return null;<br />    }<br /><br />    <em>/**<br />     * Get the JWT of the current user.<br />     *<br />     * @return the JWT of the current user.<br />     */<br />    </em>public static Optional&lt;String&gt; getCurrentUserJWT() {<br />        SecurityContext securityContext = SecurityContextHolder.<em>getContext</em>();<br />        return Optional<br />            .<em>ofNullable</em>(securityContext.getAuthentication())<br />            .filter(authentication -&gt; authentication.getCredentials() instanceof String)<br />            .map(authentication -&gt; (String) authentication.getCredentials());<br />    }<br /><br />    <em>/**<br />     * Check if a user is authenticated.<br />     *<br />     * @return true if the user is authenticated, false otherwise.<br />     */<br />    </em>public static boolean isAuthenticated() {<br />        Authentication authentication = SecurityContextHolder.<em>getContext</em>().getAuthentication();<br />        return authentication != null &amp;&amp; <em>getAuthorities</em>(authentication).noneMatch(AuthoritiesConstants.<em>ANONYMOUS</em>::equals);<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has any of the authorities.<br />     *<br />     * @param authorities the authorities to check.<br />     * @return true if the current user has any of the authorities, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserAnyOfAuthorities(String... authorities) {<br />        Authentication authentication = SecurityContextHolder.<em>getContext</em>().getAuthentication();<br />        return (<br />            authentication != null &amp;&amp; <em>getAuthorities</em>(authentication).anyMatch(authority -&gt; Arrays.<em>asList</em>(authorities).contains(authority))<br />        );<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has none of the authorities.<br />     *<br />     * @param authorities the authorities to check.<br />     * @return true if the current user has none of the authorities, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserNoneOfAuthorities(String... authorities) {<br />        return !<em>hasCurrentUserAnyOfAuthorities</em>(authorities);<br />    }<br /><br />    <em>/**<br />     * Checks if the current user has a specific authority.<br />     *<br />     * @param authority the authority to check.<br />     * @return true if the current user has the authority, false otherwise.<br />     */<br />    </em>public static boolean hasCurrentUserThisAuthority(String authority) {<br />        return <em>hasCurrentUserAnyOfAuthorities</em>(authority);<br />    }<br /><br />    private static Stream&lt;String&gt; getAuthorities(Authentication authentication) {<br />        return authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority);<br />    }<br />}</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*sA1fdRXDyh0m3piZ\" /><figcaption>Photo by <a href=\"https://unsplash.com/@fantasyflip?utm_source=medium&amp;utm_medium=referral\">Philipp Katzenberger</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Security Configurations</h4><p>SecurityConfiguration.java<br />Here we will be saying what kind of api‚Äôs need to be permitted as public¬†api‚Äôs.</p><pre>@EnableWebSecurity<br />@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)<br />@Import(SecurityProblemSupport.class)<br />public class SecurityConfiguration extends WebSecurityConfigurerAdapter {<br /><br />    private final TokenProvider tokenProvider;<br /><br />    private final CorsFilter corsFilter;<br />    private final SecurityProblemSupport problemSupport;<br /><br />    public SecurityConfiguration(<br />        TokenProvider tokenProvider,<br />        CorsFilter corsFilter,<br />        SecurityProblemSupport problemSupport<br />    ) {<br />        this.tokenProvider = tokenProvider;<br />        this.corsFilter = corsFilter;<br />        this.problemSupport = problemSupport;<br />    }<br /><br />    @Bean<br />    public PasswordEncoder passwordEncoder() {<br />        return new BCryptPasswordEncoder();<br />    }<br /><br />    @Override<br />    public void configure(WebSecurity web) {<br />        web.ignoring().antMatchers(HttpMethod.<em>OPTIONS</em>, &quot;/**&quot;).antMatchers(&quot;/swagger-ui/**&quot;).antMatchers(&quot;/test/**&quot;);<br />    }<br /><br />    @Override<br />    public void configure(HttpSecurity http) throws Exception {<br />        <em>// @formatter:off<br />        </em>http<br />            .csrf()<br />            .disable()<br />            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)<br />            .exceptionHandling()<br />                .authenticationEntryPoint(problemSupport)<br />                .accessDeniedHandler(problemSupport)<br />        .and()<br />            .headers()<br />            .contentSecurityPolicy(&quot;default-src 'self'; frame-src 'self' data:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://storage.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:&quot;)<br />        .and()<br />            .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.<em>STRICT_ORIGIN_WHEN_CROSS_ORIGIN</em>)<br />        .and()<br />            .permissionsPolicy().policy(&quot;camera=(), fullscreen=(self), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), sync-xhr=()&quot;)<br />        .and()<br />            .frameOptions()<br />            .deny()<br />        .and()<br />            .sessionManagement()<br />            .sessionCreationPolicy(SessionCreationPolicy.<em>STATELESS</em>)<br />        .and()<br />            .authorizeRequests()<br />            .antMatchers(&quot;/api/authenticate&quot;).permitAll()<br />            .antMatchers(&quot;/api/register&quot;).permitAll()<br />            .antMatchers(&quot;/api/activate&quot;).permitAll()<br />            .antMatchers(&quot;/api/account/reset-password/init&quot;).permitAll()<br />            .antMatchers(&quot;/api/account/reset-password/finish&quot;).permitAll()<br />            .antMatchers(&quot;/api/admin/**&quot;).hasAuthority(AuthoritiesConstants.<em>ADMIN</em>)<br />            .antMatchers(&quot;/api/**&quot;).authenticated()<br />            .antMatchers(&quot;/management/health&quot;).permitAll()<br />            .antMatchers(&quot;/management/health/**&quot;).permitAll()<br />            .antMatchers(&quot;/management/info&quot;).permitAll()<br />            .antMatchers(&quot;/management/prometheus&quot;).permitAll()<br />            .antMatchers(&quot;/management/**&quot;).hasAuthority(AuthoritiesConstants.<em>ADMIN</em>)<br />        .and()<br />            .httpBasic()<br />        .and()<br />            .apply(securityConfigurerAdapter());<br />        <em>// @formatter:on<br />    </em>}<br /><br />    private JWTConfigurer securityConfigurerAdapter() {<br />        return new JWTConfigurer(tokenProvider);<br />    }<br />}</pre><p>WebConfigure.java<br />Allowed domains needs be to added here to avoid COR‚Äôs related¬†issues</p><pre><em>/**<br /> * Configuration of web application with Servlet 3.0 APIs.<br /> */<br /></em>@Configuration<br />public class WebConfigurer implements ServletContextInitializer {<br /><br />    private final Logger log = LoggerFactory.<em>getLogger</em>(WebConfigurer.class);<br /><br />    private final Environment env;<br /><br />    public WebConfigurer(Environment env) {<br />        this.env = env;<br />    }<br /><br />    @Override<br />    public void onStartup(ServletContext servletContext) throws ServletException {<br />        if (env.getActiveProfiles().length != 0) {<br />            log.info(&quot;Web application configuration, using profiles: {}&quot;, (Object[]) env.getActiveProfiles());<br />        }<br /><br />        log.info(&quot;Web application fully configured&quot;);<br />    }<br /><br />    @Bean<br />    public CorsFilter corsFilter() {<br />        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();<br />        CorsConfiguration config = new CorsConfiguration();<br />        List&lt;String&gt; list = new ArrayList&lt;&gt;();<br />        list.add(&quot;*&quot;);<br />        config.setAllowedOriginPatterns(list);<br />        if (!CollectionUtils.<em>isEmpty</em>(config.getAllowedOrigins()) || !CollectionUtils.<em>isEmpty</em>(config.getAllowedOriginPatterns())) {<br />            log.debug(&quot;Registering CORS filter&quot;);<br />            source.registerCorsConfiguration(&quot;/api/**&quot;, config);<br />            source.registerCorsConfiguration(&quot;/management/**&quot;, config);<br />            source.registerCorsConfiguration(&quot;/v2/api-docs&quot;, config);<br />            source.registerCorsConfiguration(&quot;/v3/api-docs&quot;, config);<br />            source.registerCorsConfiguration(&quot;/swagger-resources&quot;, config);<br />            source.registerCorsConfiguration(&quot;/swagger-ui/**&quot;, config);<br />        }<br />        return new CorsFilter(source);<br />    }<br />}</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*dvInUHmgY9aXjguP\" /><figcaption>Photo by <a href=\"https://unsplash.com/@benjaminlehman?utm_source=medium&amp;utm_medium=referral\">benjamin lehman</a> on¬†<a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>Mongock ChangeLog</h4><p>We will be using mongock to add default user details to database like¬†admin.</p><p>In application.properties we need to give the path of the class which contains ChangeLog annotation.</p><pre>spring.data.mongodb.uri=mongodb://localhost:27017/AuthDemo<br />mongock.change-logs-scan-package=<br />com.pardhu.authdemo.config.InitialSetupMigration</pre><p>InitialSetupMigration.java</p><pre><em>/**<br /> * Creates the initial database setup.<br /> */<br /></em>@ChangeLog(order = &quot;001&quot;)<br />public class InitialSetupMigration {<br /><br />    @ChangeSet(order = &quot;01&quot;, author = &quot;initiator&quot;, id = &quot;01-addAuthorities&quot;)<br />    public void addAuthorities(MongockTemplate mongoTemplate) {<br />        Authority adminAuthority = new Authority();<br />        adminAuthority.setName(AuthoritiesConstants.<em>ADMIN</em>);<br />        Authority userAuthority = new Authority();<br />        userAuthority.setName(AuthoritiesConstants.<em>USER</em>);<br />        mongoTemplate.save(adminAuthority);<br />        mongoTemplate.save(userAuthority);<br />    }<br /><br />    @ChangeSet(order = &quot;02&quot;, author = &quot;initiator&quot;, id = &quot;02-addUsers&quot;)<br />    public void addUsers(MongockTemplate mongoTemplate) {<br />        Authority adminAuthority = new Authority();<br />        adminAuthority.setName(AuthoritiesConstants.<em>ADMIN</em>);<br />        Authority userAuthority = new Authority();<br />        userAuthority.setName(AuthoritiesConstants.<em>USER</em>);<br /><br />        User adminUser = new User();<br />        adminUser.setId(&quot;user-1&quot;);<br />        adminUser.setLogin(&quot;admin&quot;);<br />        adminUser.setPassword(&quot;$2a$10$gSAhZrxMllrbgj/kkK9UceBPpChGWJA7SYIb1Mqo.n5aNLq1/oRrC&quot;);<br />        adminUser.setFirstName(&quot;admin&quot;);<br />        adminUser.setLastName(&quot;Administrator&quot;);<br />        adminUser.setEmail(&quot;admin@localhost&quot;);<br />        adminUser.setActivated(true);<br />        adminUser.setLangKey(&quot;en&quot;);<br />        adminUser.setCreatedBy(Constants.<em>SYSTEM</em>);<br />        adminUser.setCreatedDate(Instant.<em>now</em>());<br />        adminUser.getAuthorities().add(adminAuthority);<br />        adminUser.getAuthorities().add(userAuthority);<br />        mongoTemplate.save(adminUser);<br /><br />        User userUser = new User();<br />        userUser.setId(&quot;user-2&quot;);<br />        userUser.setLogin(&quot;user&quot;);<br />        userUser.setPassword(&quot;$2a$10$VEjxo0jq2YG9Rbk2HmX9S.k1uZBGYUHdUcid3g/vfiEl7lwWgOH/K&quot;);<br />        userUser.setFirstName(&quot;&quot;);<br />        userUser.setLastName(&quot;User&quot;);<br />        userUser.setEmail(&quot;user@localhost&quot;);<br />        userUser.setActivated(true);<br />        userUser.setLangKey(&quot;en&quot;);<br />        userUser.setCreatedBy(Constants.<em>SYSTEM</em>);<br />        userUser.setCreatedDate(Instant.<em>now</em>());<br />        userUser.getAuthorities().add(userAuthority);<br />        mongoTemplate.save(userUser);<br />    }<br />}</pre><p>Now we have two Authorities. Admin and User.<br />While writing an api in controller itself we can annotate like this api can be accessed by admin only using annotations ‚Üí<br />@PreAuthorize(‚ÄúhasAuthority(\\‚Äù‚Äù + AuthoritiesConstants.<em>ADMIN </em>+ ‚Äú\\‚Äù)‚Äù)<br />@PostAuthorize(‚ÄúhasAuthority(\\‚Äù‚Äù + AuthoritiesConstants.<em>ADMIN </em>+¬†‚Äú\\‚Äù)‚Äù)</p><h4>Complete working git repo is available at <a href=\"https://github.com/propardhu/AuthDemoSpringBoot\"><strong>GitHub</strong></a><strong>¬†. Also we wrote few login and register¬†API‚Äôs.</strong></h4><p>Thank you‚Ä¶.</p><p><a href=\"https://guttikondaparthasai.medium.com/\">Pardhu Guttikonda - Medium</a></p><img alt=\"\" height=\"1\" src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8182e9c1f735\" width=\"1\" />\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"2022-07-10-spring-boot-authentication-and-authorization.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":{"light":["simplex","styles.scss"],"dark":["superhero","styles.scss"]},"toc-location":"left","title":"Spring Boot Authentication and Authorization","date":"2022-07-10","reading-time":"5 min read","categories":"spring-boot","image":"https://cdn-images-1.medium.com/max/1024/0*B2N27hdw1u8-4Gv0"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}