{"title":"Binary Tree Data Structure","markdown":{"yaml":{"title":"Binary Tree Data Structure","date":"2023-03-05","reading-time":"5 min read","categories":"graph-traversal","image":"https://cdn-images-1.medium.com/max/1024/0*lfJHOi5Merc97uWu"},"containsRefs":false,"markdown":"\n\n[click here to read this in medium](https://guttikondaparthasai.medium.com/binary-tree-data-structure-61444fb4f75a?source=rss-2c47946b91eb------2)\n\n<p>Binary Tree Traversals and problemÂ solving</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lfJHOi5Merc97uWu\" /><figcaption>Photo by <a href=\"https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral\">JJ Ying</a> onÂ <a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>ðŸ’¡ Common termsÂ :-</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/494/1*xkDLV0QqdkDxqMCjZhVD-Q.jpeg\" /><figcaption>from upGrad</figcaption></figure><p>In this article we will be Discussing different tree traversals and problem solving based on these tree traversals.<br /><strong>Note: All the code is inÂ JAVA.</strong></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*kd2W6ZjjJy5e_GXd\" /><figcaption>Photo by <a href=\"https://unsplash.com/@ellladee?utm_source=medium&amp;utm_medium=referral\">N.</a> onÂ <a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h3>ðŸŒ´ Tree TraversalsÂ : (Depth First Traversals)</h3><ol><li>In-Order</li><li>Pre-Order</li><li>Post-Order</li></ol><p>The goal of these traversals is to visit all the nodes in the binaryÂ tree.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*cxXPgxw5imaniGnNScef5g.jpeg\" /><figcaption>From GeeksforGeeks</figcaption></figure><h4>In-Order TraversalÂ :-</h4><p>In this In-order â†’<br />1. First visit all nodes on the left <br />2. visit present node <br />3. Then visit all nodes on theÂ right</p><pre>void inorder(TreeNode root) {<br />        if(root==null){<br />          return;<br />        }<br />        inorder(root.left);<br />        System.out.println(root.val);<br />        inorder(root.right);<br />}</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/submissions/679456795/\">https://leetcode.com/problems/binary-tree-inorder-traversal/submissions/679456795/</a></p><h4>Pre-Order Traversal:-</h4><p>Here we follow â†’<br />1. First visit present node<br />2. visit all nodes on the left<br />3. Then visit all nodes on theÂ right</p><pre>void preorder(TreeNode r){<br />        if(r==null){<br />            return;<br />        }<br />        System.out.println(r.val);<br />        preorder(r.left);<br />        preorder(r.right);<br />    }</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/908748627/\">https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/908748627/</a></p><h4>Post-Order Traversal:-</h4><p>Here we follow â†’<br />1. First visit all nodes on the left <br />2. Then visit all nodes on the right<br />3. Visit presentÂ node</p><pre>void postOrder(TreeNode r) {<br />        if(r ==null) {<br />            return;<br />        }<br />        postOrder(r.left);<br />        postOrder(r.right);<br />        System.out.println(r.val);<br />    }</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-postorder-traversal/submissions/908750442/\">https://leetcode.com/problems/binary-tree-postorder-traversal/submissions/908750442/</a></p><h3>ðŸ›  Level Order TraversalÂ : (Breadth First Traversal)</h3><p>Here the goal is to print the tree nodes level by level. My Implementation</p><pre>class Solution {<br />    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br />    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br />        solve(root,0);<br />        return res;<br />    }<br />    public void solve(TreeNode n,int level){<br />        if(n==null)return ;<br />        if(res.size()&gt;level){<br />            res.get(level).add(n.val);<br />        }else{<br />            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();<br />            t.add(n.val);<br />            res.add(t);<br />        }<br />        solve(n.left,level+1);<br />        solve(n.right,level+1);<br />    }<br />}</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/677053619/\">https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/677053619/</a></p><p>But BFS says to maintain the queue where we first add root node and loop by pop the node and add the children to the queue.Which also gives the similar result with sameÂ runtime.</p><h4>ðŸ¥· Example problemÂ 1</h4><p><a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\">Sum Root to Leaf Numbers - LeetCode</a></p><p>Here we need to find a way to get all possible numbers formed by traversing from the root node to each leaf node. Then sum it up. So after observing the problem statement, we can get an idea that we need to use <strong>preorder Traversal</strong>. But the Question is <strong>How we can identify the different paths from root to leaf node?</strong> So I got the idea to add an edge case to the preorder traversal saying hey if the present node leaf node here the code forÂ it.</p><pre>class Solution {<br />    int sum  = 0;<br />    public int sumNumbers(TreeNode root) {<br />        preorder(root,new StringBuilder());<br />        return sum;<br />    }<br />    public void preorder(TreeNode node, StringBuilder sb){<br />        if (node == null) return;<br /><br />        sb.append(node.val);<br /><br />        if (node.left == null &amp;&amp; node.right == null) {<br />            sum += Integer.parseInt(sb.toString());<br />        }<br />        preorder(node.left, sb);<br />        preorder(node.right, sb);<br />        sb.deleteCharAt(sb.length() - 1);<br />    }<br /><br />}<br />// https://leetcode.com/problems/sum-root-to-leaf-numbers/submissions/908758869/</pre><h4>ðŸš€ Example problemÂ 2</h4><p><a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\">Binary Tree Maximum Path Sum - LeetCode</a></p><p>This is also a very interesting problem. Where we need to find the Path where we can get the maximum Sum by adding the node values. In these case where we need to see all the nodes from the bottom of the tree. We have to go with <strong>postOrder</strong> kind of approach to solve this problem. Here is my solution.</p><pre>class Solution {<br />    int final_max = Integer.MIN_VALUE;<br />    public int maxPathSum(TreeNode root) {<br />        solve(root);<br />        return final_max;<br />    }<br />    public int solve(TreeNode root){<br />        if(root==null){return 0;}<br />        int leftMax = solve(root.left);<br />        int rightMax = solve(root.right);<br />        int send_top = Math.max(Math.max(leftMax,rightMax)+root.val,root.val);<br />        int comMax = Math.max(leftMax+rightMax+root.val,send_top);<br />        final_max = Math.max(final_max,comMax);<br />        return send_top;<br />    }<br />}<br />// https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/909178204/</pre><p>Thank youâ€¦!</p><ul><li><a href=\"https://guttikondaparthasai.medium.com/\">Pardhu Guttikonda - Medium</a></li><li><a href=\"https://leetcode.com/propardhu/\">propardhu - LeetCode Profile</a></li></ul><img alt=\"\" height=\"1\" src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=61444fb4f75a\" width=\"1\" />\n","srcMarkdownNoYaml":"\n\n[click here to read this in medium](https://guttikondaparthasai.medium.com/binary-tree-data-structure-61444fb4f75a?source=rss-2c47946b91eb------2)\n\n<p>Binary Tree Traversals and problemÂ solving</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lfJHOi5Merc97uWu\" /><figcaption>Photo by <a href=\"https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral\">JJ Ying</a> onÂ <a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h4>ðŸ’¡ Common termsÂ :-</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/494/1*xkDLV0QqdkDxqMCjZhVD-Q.jpeg\" /><figcaption>from upGrad</figcaption></figure><p>In this article we will be Discussing different tree traversals and problem solving based on these tree traversals.<br /><strong>Note: All the code is inÂ JAVA.</strong></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*kd2W6ZjjJy5e_GXd\" /><figcaption>Photo by <a href=\"https://unsplash.com/@ellladee?utm_source=medium&amp;utm_medium=referral\">N.</a> onÂ <a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h3>ðŸŒ´ Tree TraversalsÂ : (Depth First Traversals)</h3><ol><li>In-Order</li><li>Pre-Order</li><li>Post-Order</li></ol><p>The goal of these traversals is to visit all the nodes in the binaryÂ tree.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*cxXPgxw5imaniGnNScef5g.jpeg\" /><figcaption>From GeeksforGeeks</figcaption></figure><h4>In-Order TraversalÂ :-</h4><p>In this In-order â†’<br />1. First visit all nodes on the left <br />2. visit present node <br />3. Then visit all nodes on theÂ right</p><pre>void inorder(TreeNode root) {<br />        if(root==null){<br />          return;<br />        }<br />        inorder(root.left);<br />        System.out.println(root.val);<br />        inorder(root.right);<br />}</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/submissions/679456795/\">https://leetcode.com/problems/binary-tree-inorder-traversal/submissions/679456795/</a></p><h4>Pre-Order Traversal:-</h4><p>Here we follow â†’<br />1. First visit present node<br />2. visit all nodes on the left<br />3. Then visit all nodes on theÂ right</p><pre>void preorder(TreeNode r){<br />        if(r==null){<br />            return;<br />        }<br />        System.out.println(r.val);<br />        preorder(r.left);<br />        preorder(r.right);<br />    }</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/908748627/\">https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/908748627/</a></p><h4>Post-Order Traversal:-</h4><p>Here we follow â†’<br />1. First visit all nodes on the left <br />2. Then visit all nodes on the right<br />3. Visit presentÂ node</p><pre>void postOrder(TreeNode r) {<br />        if(r ==null) {<br />            return;<br />        }<br />        postOrder(r.left);<br />        postOrder(r.right);<br />        System.out.println(r.val);<br />    }</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-postorder-traversal/submissions/908750442/\">https://leetcode.com/problems/binary-tree-postorder-traversal/submissions/908750442/</a></p><h3>ðŸ›  Level Order TraversalÂ : (Breadth First Traversal)</h3><p>Here the goal is to print the tree nodes level by level. My Implementation</p><pre>class Solution {<br />    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br />    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br />        solve(root,0);<br />        return res;<br />    }<br />    public void solve(TreeNode n,int level){<br />        if(n==null)return ;<br />        if(res.size()&gt;level){<br />            res.get(level).add(n.val);<br />        }else{<br />            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();<br />            t.add(n.val);<br />            res.add(t);<br />        }<br />        solve(n.left,level+1);<br />        solve(n.right,level+1);<br />    }<br />}</pre><p>LeetCode submission â†’ <a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/677053619/\">https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/677053619/</a></p><p>But BFS says to maintain the queue where we first add root node and loop by pop the node and add the children to the queue.Which also gives the similar result with sameÂ runtime.</p><h4>ðŸ¥· Example problemÂ 1</h4><p><a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\">Sum Root to Leaf Numbers - LeetCode</a></p><p>Here we need to find a way to get all possible numbers formed by traversing from the root node to each leaf node. Then sum it up. So after observing the problem statement, we can get an idea that we need to use <strong>preorder Traversal</strong>. But the Question is <strong>How we can identify the different paths from root to leaf node?</strong> So I got the idea to add an edge case to the preorder traversal saying hey if the present node leaf node here the code forÂ it.</p><pre>class Solution {<br />    int sum  = 0;<br />    public int sumNumbers(TreeNode root) {<br />        preorder(root,new StringBuilder());<br />        return sum;<br />    }<br />    public void preorder(TreeNode node, StringBuilder sb){<br />        if (node == null) return;<br /><br />        sb.append(node.val);<br /><br />        if (node.left == null &amp;&amp; node.right == null) {<br />            sum += Integer.parseInt(sb.toString());<br />        }<br />        preorder(node.left, sb);<br />        preorder(node.right, sb);<br />        sb.deleteCharAt(sb.length() - 1);<br />    }<br /><br />}<br />// https://leetcode.com/problems/sum-root-to-leaf-numbers/submissions/908758869/</pre><h4>ðŸš€ Example problemÂ 2</h4><p><a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\">Binary Tree Maximum Path Sum - LeetCode</a></p><p>This is also a very interesting problem. Where we need to find the Path where we can get the maximum Sum by adding the node values. In these case where we need to see all the nodes from the bottom of the tree. We have to go with <strong>postOrder</strong> kind of approach to solve this problem. Here is my solution.</p><pre>class Solution {<br />    int final_max = Integer.MIN_VALUE;<br />    public int maxPathSum(TreeNode root) {<br />        solve(root);<br />        return final_max;<br />    }<br />    public int solve(TreeNode root){<br />        if(root==null){return 0;}<br />        int leftMax = solve(root.left);<br />        int rightMax = solve(root.right);<br />        int send_top = Math.max(Math.max(leftMax,rightMax)+root.val,root.val);<br />        int comMax = Math.max(leftMax+rightMax+root.val,send_top);<br />        final_max = Math.max(final_max,comMax);<br />        return send_top;<br />    }<br />}<br />// https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/909178204/</pre><p>Thank youâ€¦!</p><ul><li><a href=\"https://guttikondaparthasai.medium.com/\">Pardhu Guttikonda - Medium</a></li><li><a href=\"https://leetcode.com/propardhu/\">propardhu - LeetCode Profile</a></li></ul><img alt=\"\" height=\"1\" src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=61444fb4f75a\" width=\"1\" />\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"2023-03-05-binary-tree-data-structure.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":{"light":["simplex","styles.scss"],"dark":["superhero","styles.scss"]},"toc-location":"left","title":"Binary Tree Data Structure","date":"2023-03-05","reading-time":"5 min read","categories":"graph-traversal","image":"https://cdn-images-1.medium.com/max/1024/0*lfJHOi5Merc97uWu"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}